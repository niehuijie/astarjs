{"version":3,"file":"PathFinding.js","sourceRoot":"","sources":["../../../src/PathFinding.ts"],"names":[],"mappings":"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","sourcesContent":["import { Node } from \"./Node\";\r\n\r\nexport enum Types {\r\n    START,\r\n    END,\r\n    WALKABLE,\r\n    NON_WALKABLE\r\n}\r\n\r\nexport class PathFinding {\r\n    \r\n    constructor(){\r\n        \r\n    }\r\n\r\n    static find(map: number[][]): {col:number,row:number}[]{\r\n        let firstElement = PathFinding.findStart(map);\r\n        let lastElement = PathFinding.findEnd(map);\r\n        return PathFinding.findBestPath(firstElement, lastElement, map); \r\n    }\r\n\r\n    static findBestPath(firstElement: Node, lastElement:Node, map: number[][]): {col:number,row:number}[]{\r\n\r\n        var closedList: Node[] = [];\r\n        var openList: Node[]= [];\r\n        var isFinished: boolean = false;\r\n\r\n        closedList.push(firstElement);\r\n\r\n        while(!isFinished){\r\n            \r\n            openList = PathFinding.findValidAdjacents(map, closedList[closedList.length -1], closedList, openList, lastElement);\r\n            if(openList.length > 0)closedList.push(openList.pop() as Node);\r\n            isFinished = PathFinding.isObjectEqual(closedList[closedList.length-1],lastElement) || openList.length == 0;\r\n        }\r\n\r\n        if(openList.length > 0){\r\n            return PathFinding.getPath(closedList[closedList.length-1]);\r\n        } else {\r\n            return [];\r\n        }\r\n    }\r\n\r\n    static nodeToObject(node:Node){\r\n        return {col: node.getCol(), row: node.getRow()};\r\n    }\r\n\r\n    static getPath(node:Node):{col:number,row:number}[] {\r\n        let currentNode = node;\r\n        let listPath = [];\r\n        while(currentNode){\r\n            listPath.push(this.nodeToObject(currentNode));\r\n            currentNode = currentNode.getParent();\r\n            if(!currentNode)return listPath.reverse();\r\n        }\r\n        return [];\r\n    }\r\n\r\n    static findEnd(map:number[][]): Node {\r\n        return PathFinding.findElement(map, Types.END);\r\n    }\r\n\r\n    static findStart(map:number[][]): Node {\r\n        return PathFinding.findElement(map, Types.START);\r\n    }\r\n\r\n    static findElement(map:number[][], value:number): Node {\r\n\r\n        let el = new Node(0,0);\r\n        map.forEach((element, indexRow) => {\r\n            element.forEach((element, indexCol) => {\r\n                if(element == value){\r\n                    el = new Node(indexRow, indexCol);\r\n                }\r\n            });\r\n        });\r\n        return el;\r\n        \r\n    }\r\n\r\n    static getValueMove(node:Node, nodeNew:Node){\r\n        if(node.getRow() != nodeNew.getRow() && node.getCol() != nodeNew.getCol()) return 14;\r\n            else return 10;\r\n    }\r\n\r\n    static distanceBetweenNodes(nodeInitial:Node, nodeFinal:Node, val:number){\r\n        let col = Math.abs(nodeFinal.getCol() - nodeInitial.getCol());\r\n        let row = Math.abs(nodeFinal.getRow() - nodeInitial.getRow());\r\n        return col*val + row*val;\r\n    }\r\n\r\n    static isObjectEqual(element:Node, element0:Node):boolean{\r\n        return (element.getRow() == element0.getRow() && element.getCol() == element0.getCol());\r\n    }\r\n\r\n    static findAdjacents(map:number[][], node:Node) : Node[] {\r\n\r\n        let adjacents: Node[] = [];\r\n\r\n        let verify = [[-1,-1], [-1,0] , [-1, 1], [0,-1], \r\n                      [0,1], [1,-1], [1,0] , [1, 1]];\r\n\r\n        let mapElements = map;\r\n        \r\n        for(let v = 0; v < verify.length; v++){\r\n\r\n          var x = node.getRow() + verify[v][0];\r\n          var y = node.getCol() + verify[v][1];\r\n\r\n          if(x > -1 && y > -1 && x < mapElements.length && y < mapElements[x].length \r\n            && (mapElements[x][y] == Types.WALKABLE || mapElements[x][y] == Types.END )){\r\n                adjacents.push(new Node(x, y));\r\n          }\r\n        }\r\n\r\n        return adjacents;\r\n    }\r\n\r\n\r\n    static findValidAdjacents(map:number[][], node:Node, closedList:Node[], openList: Node[], lastElement:Node){\r\n        \r\n        let validAdjacents = PathFinding.findAdjacents(map, node).filter(\r\n            (elementAdjacent) => {\r\n                return closedList.some((element) => {\r\n                    return !(PathFinding.isObjectEqual(element, elementAdjacent))\r\n                })\r\n            });\r\n\r\n        let validAdjacentsOpenList = validAdjacents.filter(\r\n            (elementAdjacent) => {\r\n                return openList.some((element) => {\r\n                    return (PathFinding.isObjectEqual(element, elementAdjacent))\r\n                })\r\n            });\r\n\r\n        validAdjacentsOpenList.map((elementAdjacent) => {\r\n            let validElement = openList.filter((element) => (PathFinding.isObjectEqual(element, elementAdjacent)))[0];\r\n            if(( node.getG() + PathFinding.getValueMove(validElement, node)) < validElement.getG()){\r\n                validElement.setG(PathFinding.getValueMove(validElement, node));\r\n                validElement.setParent(node);\r\n            }\r\n        });\r\n\r\n        let validAdjacentsNewOpenList = validAdjacents.filter(\r\n            (elementAdjacent) => {\r\n                return !openList.some((element) => {\r\n                    return (PathFinding.isObjectEqual(element, elementAdjacent))\r\n                })\r\n            });\r\n\r\n\r\n        validAdjacentsNewOpenList.forEach((element) => {\r\n            element.setParent(node);\r\n            element.setH(PathFinding.distanceBetweenNodes(element, lastElement, 10));\r\n            element.setG(PathFinding.getValueMove(node, element));\r\n            element.setValue(element.getG() + element.getH());\r\n            openList.push(element);\r\n            \r\n        });\r\n        \r\n        openList.sort((a,b) => b.getValue() - a.getValue());\r\n        \r\n        return openList;  \r\n      }\r\n\r\n}"]}