{"version":3,"file":"PathFinding.js","sourceRoot":"","sources":["../src/PathFinding.ts"],"names":[],"mappings":"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","sourcesContent":["import { Node } from \"./Node\";\r\n\r\nexport enum Types {\r\n    START,\r\n    END,\r\n    WALKABLE,\r\n    NON_WALKABLE\r\n}\r\n\r\nexport class PathFinding {\r\n\r\n\tprivate DEFAULT_DISTANCE:number = 10;\r\n\tprivate DIAGONAL_DISTANCE:number = 14;\r\n\tprivate walkableTypes:number[] = [];\r\n\tprivate start:number;\r\n\tprivate end:number;\r\n\r\n    constructor(){\r\n\r\n\t}\r\n\t\r\n\tpublic setWalkable(...args:number[]){\r\n\t\tthis.walkableTypes = this.walkableTypes.concat(...args);\r\n\t\treturn this;\r\n\t}\r\n\r\n\tpublic setStart(start:number){\r\n\t\tthis.start = start;\r\n\t\treturn this;\r\n\t}\r\n\r\n\tpublic setEnd(end:number){\r\n\t\tthis.end = end;\r\n\t\treturn this;\r\n\t}\r\n\r\n\tprivate gameMapToPathfind(map: number[][]): number[][] {\r\n        return map.map(row=>{\r\n            return row.map(id => {\r\n\t\t\t\tif(this.start == id){\r\n\t\t\t\t\treturn Types.START;\r\n\t\t\t\t} else if(this.end == id){\r\n\t\t\t\t\treturn Types.END;\r\n\t\t\t\t} else if(this.walkableTypes.indexOf(id) > -1){\r\n                      return Types.WALKABLE;\r\n                  } else {\r\n                      return Types.NON_WALKABLE;\r\n                  }\r\n             });\r\n        });\r\n    }\r\n\r\n    public find(map: number[][]): {col:number,row:number}[]{\r\n\t\tif(!this.start){\r\n\t\t\tthrow new Error('There is no start point. Please, use setStart() to configure the path\\'s start point.');\r\n\t\t}\r\n\r\n\t\tif(!this.end){\r\n\t\t\tthrow new Error('There is no end point. Please, use setEnd() to configure the path\\'s end point.');\r\n\t\t}\r\n\r\n\t\tlet finalMap:number[][] = this.gameMapToPathfind(map);\r\n        let firstElement = this.findStartElement(finalMap);\r\n\t\tlet lastElement = this.findEndElement(finalMap);\r\n        return this.findBestPath(firstElement, lastElement, finalMap);\r\n    }\r\n\r\n\tprivate findStartElement(map:number[][]): Node {\r\n\t\treturn this.findElement(map, Types.START);\r\n\t}\r\n\r\n\tprivate findEndElement(map:number[][]): Node {\r\n\t\treturn this.findElement(map, Types.END);\r\n\t}\r\n\r\n\tprivate findElement(map:number[][], value:number): Node {\r\n\r\n\t\tlet el = new Node(0,0);\r\n\t\tmap.forEach((element, indexRow) => {\r\n\t\t\telement.forEach((element, indexCol) => {\r\n\t\t\t\tif(element == value){\r\n\t\t\t\t\tel = new Node(indexRow, indexCol);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t});\r\n\t\treturn el;\r\n\r\n\t}\r\n\r\n    private findBestPath(firstElement: Node, lastElement:Node, map: number[][]): {col:number,row:number}[]{\r\n\r\n\t\tlet closedList: Node[] = [];\r\n\t\tlet openList: Node[]= [];\r\n\t\tlet isFinished: boolean = false;\r\n\r\n        closedList.push(firstElement);\r\n\r\n        while(!isFinished){\r\n            openList = this.findValidAdjacents(map, closedList[closedList.length -1], closedList, openList, lastElement);\r\n\t\t\tif(openList.length > 0)closedList.push(openList.pop() as Node);\r\n            isFinished = this.isNodeEqual(closedList[closedList.length-1],lastElement) || openList.length == 0;\r\n        }\r\n\r\n        return (openList.length > 0) ? this.getPath(closedList[closedList.length-1]) : [];\r\n    }\r\n\r\n\tprivate findValidAdjacents(map:number[][], currentNode:Node, closedList:Node[], openList: Node[], lastElement:Node){\r\n\r\n    \t//get all adjacents position possibilities that we don't have in the closed list\r\n\t\tlet validAdjacents = this.findAdjacents(map, currentNode).filter(\r\n\t\t\t(elementAdjacent:Node) => {\r\n\t\t\t\treturn !closedList.some((element:Node) => {\r\n\t\t\t\t\treturn this.isNodeEqual(element, elementAdjacent)\r\n\t\t\t\t})\r\n\t\t\t});\r\n\r\n\t\t//get all adjacents position possibilities that we have in the open list and don't have inside the closed list\r\n\t\tlet validAdjacentsOpenList = validAdjacents.filter(\r\n\t\t\t(elementAdjacent:Node) => {\r\n\t\t\t\treturn openList.some((element:Node) => {\r\n\t\t\t\t\treturn this.isNodeEqual(element, elementAdjacent)\r\n\t\t\t\t})\r\n\t\t\t});\r\n\r\n\t\t//update distance values if the new potencial Node position on the path is longer than the current one\r\n\t\tvalidAdjacentsOpenList.forEach((elementAdjacent:Node) => {\r\n\t\t\tlet validElement = openList.filter((element:Node) => this.isNodeEqual(element, elementAdjacent))[0];\r\n\t\t\tif( currentNode.getG() + this.getMoveValue(validElement, currentNode) < validElement.getG()){\r\n\t\t\t\tvalidElement.setG(this.getMoveValue(validElement, currentNode));\r\n\t\t\t\tvalidElement.setParent(currentNode);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t//get all adjacents posiiton possibilities that we don't have in the open list and don't have inside the closed list\r\n\t\tlet validAdjacentsNewOpenList = validAdjacents.filter(\r\n\t\t\t(elementAdjacent:Node) => {\r\n\t\t\t\treturn !openList.some((element:Node) => {\r\n\t\t\t\t\treturn this.isNodeEqual(element, elementAdjacent)\r\n\t\t\t\t})\r\n\t\t\t});\r\n\r\n\t\t//update distance values for the potencial new positions in the open list\r\n\t\tvalidAdjacentsNewOpenList.forEach((element) => {\r\n\t\t\telement.setParent(currentNode);\r\n\t\t\telement.setH(this.distanceBetweenNodes(element, lastElement, this.DEFAULT_DISTANCE));\r\n\t\t\telement.setG(this.getMoveValue(currentNode, element));\r\n\t\t\topenList.push(element);\r\n\t\t});\r\n\r\n\t\topenList.sort((a,b) => b.getValue() - a.getValue());\r\n\r\n\t\treturn openList;\r\n\t}\r\n\r\n\tprivate distanceBetweenNodes(initialNode:Node, finalNode:Node, val:number){\r\n\t\tlet col = Math.abs(finalNode.getCol() - initialNode.getCol());\r\n\t\tlet row = Math.abs(finalNode.getRow() - initialNode.getRow());\r\n\t\treturn col*val + row*val;\r\n\t}\r\n\r\n\tprivate getMoveValue(node:Node, newNode:Node){\r\n\t\tif(node.getRow() != newNode.getRow() && node.getCol() != newNode.getCol()) return this.DIAGONAL_DISTANCE;\r\n\t\telse return this.DEFAULT_DISTANCE;\r\n\t}\r\n\r\n\tprivate findAdjacents(map:number[][], node:Node) : Node[] {\r\n\r\n\t\tlet adjacents: Node[] = [];\r\n\r\n\t\tlet verify = [[-1,-1], [-1,0] , [-1, 1], [0,-1],\r\n\t\t\t[0,1], [1,-1], [1,0] , [1, 1]];\r\n\r\n\t\tlet mapElements = map;\r\n\r\n\t\tfor(let v = 0; v < verify.length; v++){\r\n\r\n\t\t\tlet x = node.getRow() + verify[v][0];\r\n\t\t\tlet y = node.getCol() + verify[v][1];\r\n\r\n\t\t\tif(x > -1 && y > -1 && x < mapElements.length && y < mapElements[x].length\r\n\t\t\t\t&& (mapElements[x][y] == Types.WALKABLE || mapElements[x][y] == Types.END )){\r\n\t\t\t\tadjacents.push(new Node(x, y));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn adjacents;\r\n\t}\r\n\r\n\tprivate getPath(node:Node):{col:number,row:number}[] {\r\n        let currentNode = node;\r\n        let listPath = [];\r\n        while(currentNode){\r\n            listPath.push(this.nodeToObject(currentNode));\r\n            currentNode = currentNode.getParent();\r\n            if(!currentNode)return listPath.reverse();\r\n        }\r\n        return [];\r\n    }\r\n\r\n\tprivate nodeToObject(node:Node){\r\n\t\treturn {col: node.getCol(), row: node.getRow()};\r\n\t}\r\n\r\n\tprivate isNodeEqual(element:Node, element0:Node):boolean{\r\n        return (element.getRow() == element0.getRow() && element.getCol() == element0.getCol());\r\n\t}\r\n\r\n}"]}