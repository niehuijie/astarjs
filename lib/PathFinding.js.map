{"version":3,"file":"PathFinding.js","sourceRoot":"","sources":["../src/PathFinding.ts"],"names":[],"mappings":"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","sourcesContent":["import { Node } from \"./Node\";\r\n\r\nexport enum Types {\r\n    START,\r\n    END,\r\n    WALKABLE,\r\n    NON_WALKABLE\r\n}\r\n\r\nexport class PathFinding {\r\n    \r\n    constructor(){\r\n\r\n    }\r\n\r\n    public find(map: number[][]): {col:number,row:number}[]{\r\n        let firstElement = this.findStart(map);\r\n        let lastElement = this.findEnd(map);\r\n        return this.findBestPath(firstElement, lastElement, map);\r\n    }\r\n\r\n    private findBestPath(firstElement: Node, lastElement:Node, map: number[][]): {col:number,row:number}[]{\r\n\r\n\t\tlet closedList: Node[] = [];\r\n\t\tlet openList: Node[]= [];\r\n\t\tlet isFinished: boolean = false;\r\n\r\n        closedList.push(firstElement);\r\n\r\n        while(!isFinished){\r\n            \r\n            openList = this.findValidAdjacents(map, closedList[closedList.length -1], closedList, openList, lastElement);\r\n            if(openList.length > 0)closedList.push(openList.pop() as Node);\r\n            isFinished = this.isObjectEqual(closedList[closedList.length-1],lastElement) || openList.length == 0;\r\n        }\r\n\r\n        if(openList.length > 0){\r\n            return this.getPath(closedList[closedList.length-1]);\r\n        } else {\r\n            return [];\r\n        }\r\n    }\r\n\r\n\tprivate nodeToObject(node:Node){\r\n        return {col: node.getCol(), row: node.getRow()};\r\n    }\r\n\r\n\tprivate getPath(node:Node):{col:number,row:number}[] {\r\n        let currentNode = node;\r\n        let listPath = [];\r\n        while(currentNode){\r\n            listPath.push(this.nodeToObject(currentNode));\r\n            currentNode = currentNode.getParent();\r\n            if(!currentNode)return listPath.reverse();\r\n        }\r\n        return [];\r\n    }\r\n\r\n\tprivate findEnd(map:number[][]): Node {\r\n        return this.findElement(map, Types.END);\r\n    }\r\n\r\n\tprivate findStart(map:number[][]): Node {\r\n        return this.findElement(map, Types.START);\r\n    }\r\n\r\n\tprivate findElement(map:number[][], value:number): Node {\r\n\r\n        let el = new Node(0,0);\r\n        map.forEach((element, indexRow) => {\r\n            element.forEach((element, indexCol) => {\r\n                if(element == value){\r\n                    el = new Node(indexRow, indexCol);\r\n                }\r\n            });\r\n        });\r\n        return el;\r\n        \r\n    }\r\n\r\n\tprivate getValueMove(node:Node, nodeNew:Node){\r\n        if(node.getRow() != nodeNew.getRow() && node.getCol() != nodeNew.getCol()) return 14;\r\n            else return 10;\r\n    }\r\n\r\n\tprivate distanceBetweenNodes(nodeInitial:Node, nodeFinal:Node, val:number){\r\n        let col = Math.abs(nodeFinal.getCol() - nodeInitial.getCol());\r\n        let row = Math.abs(nodeFinal.getRow() - nodeInitial.getRow());\r\n        return col*val + row*val;\r\n    }\r\n\r\n\tprivate isObjectEqual(element:Node, element0:Node):boolean{\r\n        return (element.getRow() == element0.getRow() && element.getCol() == element0.getCol());\r\n    }\r\n\r\n\tprivate findAdjacents(map:number[][], node:Node) : Node[] {\r\n\r\n        let adjacents: Node[] = [];\r\n\r\n        let verify = [[-1,-1], [-1,0] , [-1, 1], [0,-1], \r\n                      [0,1], [1,-1], [1,0] , [1, 1]];\r\n\r\n        let mapElements = map;\r\n        \r\n        for(let v = 0; v < verify.length; v++){\r\n\r\n          let x = node.getRow() + verify[v][0];\r\n          let y = node.getCol() + verify[v][1];\r\n\r\n          if(x > -1 && y > -1 && x < mapElements.length && y < mapElements[x].length \r\n            && (mapElements[x][y] == Types.WALKABLE || mapElements[x][y] == Types.END )){\r\n                adjacents.push(new Node(x, y));\r\n          }\r\n        }\r\n\r\n        return adjacents;\r\n    }\r\n\r\n\r\n\tprivate findValidAdjacents(map:number[][], node:Node, closedList:Node[], openList: Node[], lastElement:Node){\r\n        \r\n        let validAdjacents = this.findAdjacents(map, node).filter(\r\n            (elementAdjacent) => {\r\n                return closedList.some((element) => {\r\n                    return !(this.isObjectEqual(element, elementAdjacent))\r\n                })\r\n            });\r\n\r\n        let validAdjacentsOpenList = validAdjacents.filter(\r\n            (elementAdjacent) => {\r\n                return openList.some((element) => {\r\n                    return (this.isObjectEqual(element, elementAdjacent))\r\n                })\r\n            });\r\n\r\n        validAdjacentsOpenList.map((elementAdjacent) => {\r\n            let validElement = openList.filter((element) => (this.isObjectEqual(element, elementAdjacent)))[0];\r\n            if(( node.getG() + this.getValueMove(validElement, node)) < validElement.getG()){\r\n                validElement.setG(this.getValueMove(validElement, node));\r\n                validElement.setParent(node);\r\n            }\r\n        });\r\n\r\n        let validAdjacentsNewOpenList = validAdjacents.filter(\r\n            (elementAdjacent) => {\r\n                return !openList.some((element) => {\r\n                    return (this.isObjectEqual(element, elementAdjacent))\r\n                })\r\n            });\r\n\r\n\r\n        validAdjacentsNewOpenList.forEach((element) => {\r\n            element.setParent(node);\r\n            element.setH(this.distanceBetweenNodes(element, lastElement, 10));\r\n            element.setG(this.getValueMove(node, element));\r\n            element.setValue(element.getG() + element.getH());\r\n            openList.push(element);\r\n            \r\n        });\r\n        \r\n        openList.sort((a,b) => b.getValue() - a.getValue());\r\n        \r\n        return openList;  \r\n      }\r\n\r\n}"]}